"""
В этой задаче вам предстоит построить лесенку из чисел.
Программа принимает на вход целое положительное число n (n<=15) - количество
уровней, ваша задача вывести n уровней, в каждом из которых стоят числа от 1
до значения уровня.
"""
n = int(input())
for i in range(1,n+1):
    for j in range(1, i + 1):
        print(j,end=' ')
    print()

"""
Постулат Бертрана (теорема Бертрана-Чебышева, теорема Чебышева) гласит, 
что для любого n > 1 найдется простое число p в интервале n < p < 2n. 
Такая гипотеза была выдвинута в 1845 году французским математиком Джозефем Бертраном 
(проверившим ее до n=3000000) и доказана в 1850 году Пафнутием Чебышевым. 
Рамануджан в 1920 году нашел более простое доказательство, 
а Эрдеш в 1932 – еще более простое.
Ваша задача состоит в том, чтобы решить несколько более общую задачу – а именно 
по числу n найти количество простых чисел p из интервала n < p < 2n.
Напомним, что число называется простым, если оно делится только 
само на себя и на единицу.
Входные данные
Программа принимает на вход целое число n (2 ≤ n ≤ 50000).
Выходные данные
Вам необходимо вывести на экран одно число – количество простых 
чисел p на интервале  n < p < 2n.
"""
n = int(input())
count = 0
for p in range (n+1,2*n):
    if p%2 == 0 and p != 2 or p == 1:
        continue
    d = 3
    is_plane=True
    while d*d<=p:
        if p%d==0:
            is_plane=False
            break
        d+=2
    if is_plane:
        count += 1
print (count)

"""
Напишите программу для построения горизонтальных столбчатых 
диаграмм с помощью символа звёздочки. 
Формат ввода
Несколько натуральных чисел на одной строке.
Формат вывода
Несколько чисел на одной строке.
"""
n = list(map(int, input().split()))
for i in n:
    for j in range(i):
        print('*', end="")
    print()

"""
Ваша задача отсортировать список по возрастанию при помощи пузырьковой сортировки, 
в случае если элементы соседние совпадают менять их ненужно.
В качестве ответа нужно вывести отсортированный список и какое количество 
раз пришлось переставлять элементы в процессе сортировки
"""
n = int(input())
a = list(map(int, input().split()))
count = 0
for i in range(n):
    for j in range(0,n-i-1):
        if a[j] > a[j+1]:
            a[j],a[j+1] = a[j+1],a[j]
            count += 1
print(*a)
print(count)

"""
Программа получает на вход число n - количество элементов в списке, 
и затем в следующей строке сам список.
Ваша задача отсортировать список по возрастанию при помощи сортировки вставками, 
в случае если элементы соседние совпадают менять их ненужно.
В качестве ответа нужно вывести отсортированный список.
"""
n = int(input())
list_num = list(map(int, input().split()))
# Сортировку начинаем со второго элемента, т.к. считается, что первый элемент уже отсортирован
for i in range(1, n):
    item_to_insert = list_num[i]
# Сохраняем ссылку на индекс предыдущего элемента
    j = i - 1
# Элементы отсортированного сегмента перемещаем вперёд, если они больше
# элемента для вставки
    while j >= 0 and list_num[j] > item_to_insert:
        list_num[j + 1] = list_num[j]
        j -= 1
# Вставляем элемент
    list_num[j + 1] = item_to_insert
print(*list_num)

"""
Вам нужно посчитать сумму элементов двумерного квадратного (NxN) списка, 
которые расположены на главной диагонали.
Под главной диагональю матрицы подразумевается диагональ, 
проведённая из левого верхнего угла в правый нижний.
Программа сперва принимает на вход число N (N<=15) - количество строк и 
столбцов в списке, а затем в N строках записаны элементы списка.
"""
# вводим количество строк и столбцов одновременно это и есть двумерний квадратный список (массив)
n = int(input())
a = []
for i in range(n):
# вместо второй функции j и списка b сразу n раз вводим список
    a.append([int(x) for x in input().split()])
# создаем переменную счетчик суммы
    s=0
for i in range(len(a)):
    for j in range(len(a)):
        if i == j:  # если i равно j ( это и есть по диагонали )
            s += a[i][j]  # тогда увеличим сумму на это число
print(s)

"""
Обход элементов матрицы - 1
Задана целочисленная квадратная матрица размером N x N. 
Необходимо обойти элементы этой матрицы сверху вниз слева направо и 
вывести элементы именно в таком порядке в виде таблицы. 
Программа принимает на вход натуральное число N – количество строк и столбцов матрицы. 
В каждой из последующих N строк записаны N целых чисел – элементы матрицы. 
Все числа во входных данных не превышают 100 по абсолютной величине.
"""
n=int(input())
m=[]
for i in range(n):
    m.append(list(map(int,input().split())))
for a in range(n):
    for s in range(n):
        print(m[s][a], end=' ')
    print()

"""
Обход элементов матрицы - 2
Задана целочисленная квадратная матрица размером N x N. 
Необходимо обойти элементы этой матрицы снизу вверх справо налево и вывести 
элементы именно в таком порядке в виде таблицы. 
Программа принимает на вход натуральное число N – количество строк и столбцов матрицы. 
В каждой из последующих N строк записаны N целых чисел – элементы матрицы. 
"""
n=int(input())
m=[]
for i in range(n):
    m.append(list(map(int,input().split())))
for a in range(n-1,-1,-1):
    for s in range(n-1,-1,-1):
        print(m[s][a], end=' ')
    print()

"""
Обход элементов матрицы - 3
Задана целочисленная матрица, состоящая из N строк и M столбцов. 
Необходимо обойти элементы этой матрицы cправо налево сверху вниз и вывести 
элементы именно в таком порядке в виде таблицы. 
Программа принимает на вход два натуральных числа N и M – количество строк 
и столбцов матрицы. В каждой из последующих N строк записаны M целых 
чисел – элементы матрицы.
"""
n, k = map(int, input().split())
m = []
for i in range(n):
    m.append(list(map(int, input().split())))

for a in range(n):
    for s in range(k - 1, -1, -1):
        print(m[a][s], end=' ')
    print()

"""
Обход элементов матрицы - 4
Задана целочисленная матрица, состоящая из N строк и M столбцов. 
Необходимо обойти элементы этой матрицы слева направо снизу вверх и вывести 
элементы именно в таком порядке в виде таблицы. 
Программа принимает на вход два натуральных числа N и M – количество строк 
и столбцов матрицы. В каждой из последующих N строк записаны M целых чисел – элементы 
матрицы. 
"""
n,k = map(int, input().split())
m=[]
for i in range(n):
    m.append(list(map(int,input().split())))
for a in range(n-1,-1,-1):
    for s in range(k):
        print(m[a][s], end=' ')
    print()

"""
Сумма строк и столбцов двумерного массива 
Задан целочисленный двумерный массив, состоящий из N строк и M столбцов. 
Требуется вычислить сумму элементов в каждой строке и в каждом столбце.
Программа получает на вход два натуральных числа N и M – количество строк и 
столбцов двумерного массива. В каждой из последующих N строк записаны M целых 
чисел – элементы массива. Все числа во входных данных не превышают 1000 по 
абсолютной величине.
В первой строке вам необходимо вывести N чисел – суммы элементов массива 
для каждой строки в отдельности.
Во второй строке в аналогичном формате выведите M чисел – суммы элементов 
для каждого столбца.
"""
n, k = map(int, input().split())
m = []
for i in range(n):
    m.append(list(map(int, input().split())))

for a in range(n):
    sum_str = 0
    for s in range(k):
        sum_str += m[a][s]
    print(sum_str, end=' ')
print()

for s in range(k):
    sum_stb = 0
    for a in range(n):
        sum_stb += m[a][s]
    print(sum_stb, end=' ')

"""
Проверьте, является ли двумерный массив симметричным относительно главной диагонали. 
Главная диагональ — та, которая идёт из левого верхнего угла двумерного массива 
в правый нижний.
Входные данные
Программа получает на вход число n<100, являющееся числом строк и столбцов 
в массиве. Далее во входном потоке идет n строк по n чисел, являющихся 
элементами массива.
Выходные данные
Программа должна выводить слово Yes для симметричного массива и слово No для 
несимметричного.
"""
n = int(input())
a = []
b = 0
for i in range(n):
    a.append(list(map(int,input().split())))

for i in range (n):
    for j in range (n):
        if i > j:
            b += a[i][j]
        elif i <j :
            b -= a[i][j]
if b == 0:
    print ('Yes')
else:
    print ('No')

"""
В метании молота состязается n спортcменов. Каждый из них сделал m бросков. 
Победителем считается тот спортсмен, у которого сумма результатов по всем 
броскам максимальна.
Если перенумеровать спортсменов числами от 0 до n-1, а попытки каждого 
из них – от 0 до m-1, то на вход программа получает массив A[n][m], 
состоящий из неотрицательных целых чисел. Программа должна определить 
максимальную сумму чисел в одной строке и вывести на экран эту сумму и 
номер строки, для которой достигается эта сумма.
Входные данные
Программа получает на вход два числа n и m, являющиеся числом строк и 
столбцов в массиве. Далее во входном потоке идет n строк по m чисел, 
являющихся элементами массива.
Выходные данные
Программа должна вывести  2 числа: сумму и номер строки, для которой эта 
сумма достигается. Если таких строк несколько, то выводится номер 
наименьшей из них. Не забудьте, что нумерация строк (спортсменов) начинается с 0.
"""
n,k = map(int, input().split())
m=[]
for i in range(n):
    m.append(list(map(int,input().split())))

l = []
for i in range(n):
    l.append(sum(m[i]))
print(max(l))
print(l.index(max(l)))

"""
В метании молота состязается n спортcменов. Каждый из них сделал m бросков. 
Победителем соревнований объявляется тот спортсмен, у которого максимален 
наилучший результат по всем броскам. Таким образом, программа должна 
найти значение максимального элемента в данном массиве, а также его индексы 
(то есть номер спортсмена и номер попытки).
Входные данные
Программа получает на вход два числа n и m, являющиеся числом строк и 
столбцов в массиве. Далее во входном потоке идет n строк по m чисел, 
являющихся элементами массива.
Выходные данные
Программа выводит значение максимального элемента, затем номер 
строки и номер столбца, в котором он встречается. Если в массиве несколько 
максимальных элементов, то нужно вывести минимальный номер строки, 
в которой встречается такой элемент, а если в этой строке таких элементов 
несколько, то нужно вывести минимальный номер столбца. 
Не забудьте, что все строки и столбцы нумеруются с 0.
"""
n,k = map(int, input().split())
m=[]
a = 0 # max элемент
b = 0 # номер строки в котором он встречается
c = 0 # номер столбца в котором он встречается
for i in range(n):
    m.append(list(map(int,input().split())))

for i in range(n):
    for j in range(k):
        if m[i][j] > a:
            a,b,c = m[i][j],j,i
print(a)
print(c,b)

"""
В метании молота состязается n спортcменов. Каждый из них сделал m бросков. 
Побеждает спортсмен, у которого максимален наилучший бросок. 
Если таких несколько, то из них побеждает тот, у которого наилучшая сумма 
результатов по всем попыткам. Если и таких несколько, победителем считается 
спортсмен с минимальным номером. Определите номер победителя соревнований.
Входные данные
Программа получает на вход два числа n и m, являющиеся числом строк и 
столбцов в массиве. Далее во входном потоке идет n строк по m чисел, 
являющихся элементами массива.
Выходные данные
Программа должна вывести одно число - номер победителя соревнований. 
Не забудьте, что  строки  (спортсмены) нумеруются с 0.
"""
n,k = map(int, input().split())
a = 0 # max элемент
b = 0 # индекс строки максимального значения
c = 0 # сумма всех
for i in range(n):
    m = list(map(int, input().split()))
    for j in range(k):
        if m[j] > a or (m[j] == a and sum(m) > b):
            a,c,b = m[j],i,sum(m)
print(c)

"""
В метании молота состязается n спортcменов. Каждый из них сделал m бросков. 
Победитель определяется по лучшему результату. 
Определите количество участников состязаний, которые разделили первое место, 
то есть определите количество строк в массиве, которые содержат значение, 
равное наибольшему.
Входные данные
Программа получает на вход два числа n и m, являющиеся числом строк 
и столбцов в массиве. Далее во входном потоке идет n строк по m чисел, 
являющихся элементами массива.
Выходные данные
Программа должна вывести  одно число - количество победителей соревнования.
"""
n,k = map(int, input().split())
m=[]
for i in range(n):
    m.append(list(map(int,input().split())))
maximum = []
for j in range(n):
    maximum.append(max(m[j]))
print(maximum.count(max(maximum)))

"""
Рассмотрим таблицу из n строк и n столбцов. Известно, что в клетке, 
образованной пересечением i-й строки и j-го столбца, 
записано число i*j. Строки и столбцы нумеруются с единицы.
Дано целое положительное число x. Требуется посчитать количество клеток таблицы, 
в которых находится число x.
Входные данные
В единственной строке находятся числа n и x (1≤n≤10**5, 1≤x≤10**9) — размер 
таблицы и число, которое мы ищем в таблице.
Выходные данные
Выведите единственное число: количество раз, которое число x встречается в таблице.
"""
n, m = map(int, input().split())
a = [[0] * 10 for i in range(n)]
for i in range(n):
    for j in range(n):
        a[i][j] = (i + 1) * (j + 1)
        a.append(a[i][j])
print(a.count(m))

"""
Фотография представляет собой матрицу размера n*m, в каждой ячейке которой 
хранится символ, обозначающий цвет соответствующего пикселя. 
Всего существует 6 цветов:
'C' (cyan) — голубой
'M' (magenta) — пурпурный
'Y' (yellow) — желтый
'W' (white) — белый
'G' (grey) — серый
'B' (black) — черный
Фотографию можно считать черно-белой, если в ней есть только белый, 
серый или черный цвет. Если же присутствует хоть один пиксель голубого, 
пурпурного или желтого цвета, она цветная.
Входные данные
В первой строке содержится два целых числа n и m (1≤n,m≤100) — количество 
строк и столбцов в матрице пикселей фотографии соответственно.
Далее следуют n строк, описывающих строки матрицы. 
Каждая из них состоит из m разделенных пробелом символов, 
описывающих цвета пикселей в строке. Каждый из символов в строке 
является одним из символов 'C', 'M', 'Y', 'W', 'G' или 'B'.
Выходные данные
В единственной строчке выведите «#Black&White» (без кавычек), 
если фотография черно-белая, и «#Color» (без кавычек), если цветная.
"""
n,m = map(int, input().split())
a = []
for x in range(n):
    a.append(list(map(str, input().split())))
count = 0
for i in range(n):
    for j in range(m):
        if a[i][j] == 'C' or a[i][j] == 'M' or a[i][j] == 'Y':
            count += 1

if count != 0:
    print('#Color')
else:
    print('#Black&White')




"""
Пользователь вводит числа, и пока введённые числа не равны нулю,
программа работает, как только происходит иное –завершает работу.
"""
n = int(input())
while n != 0:
    n = int(input())

"""
Мишка Лимак хочет стать самым большим медведем, ну, 
или хотя бы стать больше своего старшего брата Боба.
Сейчас вес Лимака равен a, а вес Боба равен b. Гарантируется, 
что вес Лимака меньше или равен весу Боба.
Лимак ест много, и его вес утраивается каждый год, 
а вес Боба удваивается каждый год.
Через сколько целых лет Лимак станет строго больше 
(т. е. будет весить строго больше) Боба?
В единственной строке находятся два целых числа a и b 
(1<= a<=b<=0) — веса Лимака и Боба соответственно.
Выведите одно целое число — через сколько целых лет Лимак станет строго больше Боба.
"""
l, b = map(int, input().split())
year = 0
while l <= b:
    l = l * 3
    b = b * 2
    year +=1
print(year)

"""
На вход программе поступает слово. Вам необходимо воспроизвести процесс, 
в котором каждый раз у этого слово будет пропадать первая и последняя буква. 
Этот процесс необходимо закончить, когда слове останется только одна 
буква или слово  станет пустой строкой. При этом результат каждого этапа нужно выводить
"""
n = input()
print(n)
while len(n) >= 1:
    n = n[1:-1]
    print(n)

"""
Выведите все точные квадраты натуральных чисел, 
не превосходящие данного числа N.
Задано единственное целое число N
Необходимо вывести  все точные квадраты натуральных чисел, 
не превосходящие данного числа N.
"""
n = int(input())
i = 1
while i**2 <= n:
    print(i**2)
    i += 1

"""
В первый день спортсмен пробежал X километров. В каждый последующий день он 
увеличивал пробег на 15% от предыдущего дня. 
Вам необходимо определить номер дня, в который пробег спортсмена составил 
не менее Y километров. Само число Y будем поступать на вход программе.
Входные данные
Программа получает на вход два положительных вещественных числа X и Y (X,Y ≤ 1000).
Выходные данные
Выведите целое число – номер дня, в который спортсмен пробежал не менее Y километров.
"""
x, y = map(int, input().split())
count = 1
while x < y:
    x = x + ((x/100) * 15)
    count += 1
print(count)

"""
У Васи есть n пар носков. Утром каждого дня, собираясь в школу, 
Вася должен надеть пару носков. Вечером, прийдя со школы, 
Вася снимает надетые носки и выбрасывает их. Каждый m-й день 
(в дни с номерами m,2m,3m,...) мама покупает Васе одну пару носков. 
Она делает это поздно вечером, поэтому Вася может надеть новые носки 
не раньше следующего дня. На сколько подряд идущих дней Васе хватит носков?
В единственной строке записано два целых числа n и m 
(1<=n<=100; 2<=m<=>100), разделенные пробелом.
Выведите единственное целое число — ответ на задачу.
"""
socks,socksM=map(int,input().split()) # ввод данных в одной строке
#socks = int(input()) # начальное кол-во носков
#socksM = int(input()) # Каждый M день мама добавляет носки
# Каждый день минус 1 носок, каждый M день 1 носок добавляется, на сколько дней хватит носков?
days = 0

while socks > 0: # цикл работает пока кол-во носков больше нуля
    socks = socks - 1 # сколько носков осталось, отнимаем по одному кажлдый день.
    #print('Кол-во носков', socks)
    days = days + 1 # увеличиваем счетчик дней
    #print('Дни', socks)
    if days % socksM == 0: # проверка, что настал М день, т.е. надо добавлять +1 носок от мамы
        socks = socks + 1 #увеличиваем кол-во носков на 1 (носок от мамы)
print (days)

"""
Возьмём число. Умножим его на его же первую цифру. 
Результат умножим на первую цифру результата. И так далее. Например, начнём с 8:
8 -> 8*8=64
64 -> 6*64=384
384 -> 3*384 =1152
1152 -> 1*1152 =11528→8∗8=64
64→6∗64=384
384→3∗384=1152
1152→1∗1152=1152
Очевидно, когда первая цифра очередного числа в такой последовательности 
становится равной 1, числа перестают изменяться. 
Но это происходит не при всех начальных числах.
Напишем программу, которая будет хотя бы приблизительно определять 
судьбу введённого числа n.
Начиная с числа n, умножайте имеющееся число на его первую цифру, 
пока у получившегося числа первая цифра не станет равной 1, 
ибо пока оно не превысит миллиарда. В качестве ответа выведите результат
"""
n = int(input())
while str(n)[0] != '1' and n <= 1000000000:
    n = int(str(n)[0]) * n
print(n)

"""
В архитектуре компьютера важную роль играют числа, являющиеся степенями двойки: 1, 2, 4, 8 и так далее. Напишите программу, которая проверяет, является ли введённое натуральное число степенью двойки. 
Если да, то выводится сама эта степень; если нет, выводится «НЕТ»
"""
a = int(input())
i = 0
f = 0
while f < a:
    f=2**i
    i = i + 1
if f==a:
    print (i-1)
else:
    print('НЕТ')

"""
По случаю 100500-летия Берляндского государственного университета совсем скоро 
состоится бал! Уже n юношей и m девушек во всю репетируют вальс, менуэт, 
полонез и кадриль.
Известно, что на бал будут приглашены несколько пар юноша-девушка, 
причем уровень умений танцевать партнеров в каждой паре должен отличаться 
не более чем на единицу.
Для каждого юноши известен уровень его умения танцевать. Аналогично, 
для каждой девушки известен уровень ее умения танцевать. Напишите программу, 
которая определит наибольшее количество пар, которое можно образовать из n 
юношей и m девушек.
Входные данные
В первой строке записано целое число n (1<=n<=>100) — количество юношей. 
Вторая строка содержит последовательность a1,a2,...,an (1<=ai<=100), 
где ai — умение танцевать i-го юноши.
Аналогично, третья строка содержит целое m (1<=m<=>100) – количество девушек. 
В четвертой строке содержится последовательность b1,b2,...,bm (1<=bj<=>100), 
где bj — умение танцевать j-й девушки.
Выходные данные
Выведите единственное число — искомое максимальное возможное количество пар.
"""
n_men = int(input())
men = sorted(list(map(int, input().split()))) # Сортируем по неубыванию
n_women = int(input())
women = sorted(list(map(int, input().split()))) # Сортируемпо неубыванию
n = 0
while men and women:
    if men[0] - 1 <= women[0] <= men[0] + 1:
        n += 1
        men.pop(0)
        women.pop(0)
    elif men[0] < women[0]: # Если же они друг другу не подходят, то удаляем наименьший из них:
        men.pop(0)
    elif men[0] > women[0]:
        women.pop(0)
print(n)

"""
Ване на день рождения подарили n кубиков. Он с друзьями решил построить 
из них пирамиду. Ваня хочет построить пирамиду следующим образом: 
на верхушке пирамиды должен находиться 1 кубик, на втором уровне — 
1+2=3 кубика, на третьем — 1+2+3=6 кубиков, и так далее. 
Таким образом, на i-м уровне пирамиды должно располагаться 
1+2+...+(i-1)+i кубиков.
Ваня хочет узнать, пирамиду какой максимальной высоты он может 
создать с использованием имеющихся кубиков.
Входные данные
В первой строке записано целое число n (1<=n<=>104) — количество кубиков, 
подаренных Ване.
Выходные данные
Выведите единственной строкой максимально возможную высоту пирамиды.
"""
n = int(input())
count = 1
i = 1
while i < n:
    i = i + i*2
    count += 1
print(count)

"""
Программист Василий любит романтику — поэтому на этот Новый Год 
он решил освещать свою комнату свечами.
У Василия есть a свечей. Когда Василий зажигает новую свечу, 
сначала она горит ровно один час, а затем тухнет. Василий — 
сообразительный малый, поэтому из b потухших свечей он умеет 
получать одну новую свечу. В последствии эту новую свечу 
(так же как и другие новые свечи) можно зажечь.
Теперь Василию интересно, на сколько часов освещения хватит его свечек, 
если он будет действовать оптимальным образом. Помогите ему найти это число.
Входные данные
В единственной строке заданы два целых числа a и b 
(1<=a<=>1000; 2<=b<=>1000).
Выходные данные
Выведите единственное целое число — количество часов, 
которое Василий сможет освещать комнату.
"""
n,m = map(int, input().split())
count = 0
while n > 0:
    n -= 1
    count += 1
    if count % m == 0:
        count += 1
print(count)

"""
В последний день уходящего 2016 года Лимак собирается принять участие в 
соревновании по спортивному программированию. Соревнование начнётся 
в 20:00 и будет продолжаться четыре часа, то есть ровно до полуночи. 
Участникам будет предложено n задач, упорядоченных по возрастанию сложности, 
то есть задача 1 будет самой лёгкой, а задача номер n — самой сложной. 
Лимак знает, что ему потребуется 5·i минут на решение i-й задачи.
Друзья Лимака планирую устроить роскошную новогоднюю вечеринку и Лимак 
хочет прибыть в полночь или ранее. Он знает, что ему требуется 
ровно k минут чтобы добрать до места проведения вечеринки от своего дома, 
где он собирается участвовать в соревновании.
Сколько максимум задач может успеть решить Лимак, так чтобы не опоздать 
на новогоднюю вечеринку?
Входные данные
В первой строке входных данных записаны два целых числа n и k 
(1<=n<=>10, 1<=k<=>240) — количество задач в соревновании и количество минут, 
за которое Лимак доберётся от дома до места проведения вечеринки.
Выходные данные
Выведите одно целое число, равное максимальному количеству задач, 
которое может решить Лимак, так чтобы прибыть на новогоднюю 
вечеринку ровно в полночь или раньше.
"""
n,k = map(int,input().split())
i = 1
t = 5*i
while t <= (240 - k) and i <= n:
        i += 1
        t = t+(5*i)
print(i-1)

"""
Слияние списков
В вашем распоряжении имеется два отсортированных списка по неубыванию 
элементов, состоящих из n и m элементов
Ваша задача слить их в один отсортированный список размером  n + m
Входные данные
Программа получает на вход два числа n и m - количество элементов 
первого списка и второго списков
Затем с новой строки поступают элементы первого отсортированного 
списка, а со следующей строки - второго списка
Выходные данные
Слить два списка в один в порядке неубывания и вывести элементы полученного списка
"""
n,m = map(int, input().split())
n_1 = list(map(int, input().split()))
m_1 = list(map(int, input().split()))
n_1.extend(m_1)
lenn_1 = len(n_1)
f = []
while n_1:
    for i in range(lenn_1):
        f.append(min(n_1))
        n_1.remove(min(n_1))
print(*f)

"""
Андроид Андреид — известный на всю галактику детектив. 
В свободное от работы время он размышляет о строках из нулей и единиц.
Как-то раз ему в голову пришла строка длины n, состоящая из нулей и единиц. 
Рассмотрим следующую операцию — мы выбираем любые две соседние позиции в строке, 
и если в одной из них ноль, а в другой — единица, то разрешается удалить обе э
ти цифры, в результате чего строка строка становится длины n-2.
Андреид задумался — какой минимальной длины строка может остаться, 
если применить описанную операции некоторое (возможно, нулевое) количество раз?
Входные данные
В первой строке входных данных задано целое число n (1<=n<=>2·10**5) — длина строки, 
которая пришла в голову Андреиду.
Во второй строке записана строка длины n, состоящая из нулей и единиц.
Выходные данные
Выведите единственное целое число — минимальное возможное значение длины строки, 
которая останется после применения операций, описанных в условии задачи.
"""
n = int(input())
a = input()
count = 0
a = ''.join(a)
b = list(a)
while '0' in b and '1' in b:
    b.remove('0')
    b.remove('1')
    count = count + 1
print(len(b))

"""
Программа принимает на вход одно натуральное число и 
выводит на экран сумму цифр данного числа
"""
n = int(input())
sum = 0
while n > 0:
    sum += n % 10
    n = n // 10
print (sum)

"""
Программа принимает на вход одно натуральное число и 
выводит на экран произведение цифр данного числа
"""
n = int(input())
a = 1
while n > 0:
    a *= n % 10
    n = n // 10
print (a)

"""
Программа принимает на вход одно натуральное число. 
Ваша задачи найти сколько раз встречается цифра 7 в этом числе
"""
n = int(input())
count = 0
while n > 0:
    a = n % 10
    n = n //10
    if a == 7:
        count += 1
print (count)

"""
Даны два натуральных числа A и B. 
Требуется найти их наибольший общий делитель (НОД) методом вычитания
"""
a,b = map(int, input().split())
while a != b:
    if a > b:
        a = a - b
    else:
        b = b - a
print(a)

"""
Та же самая задача, необходимо найти НОД двух чисел, 
только теперь нужно модернизировать свой код при помощи 
нахождения остатка от деления
"""
a,b = map(int, input().split())
while b > 0:
    a,b = b, a%b
print(a)

"""
Даны два натуральных числа A и B. Требуется найти их наименьшее общее кратное (НОК).
"""
a,b = map(int, input().split())
c = 0
d = a*b
while a != b:
    if a > b:
        a = a - b
    else:
        b = b - a
c = a
nok = d / c
print(int(nok))

"""
Дано натуральное число N. Определить, является ли оно простым. 
Натуральное число N называется простым, если у него есть только два делителя: 
единица и само число N. 
В качестве ответа выведите "Yes", если число простое,  "No" - в противном случае.
"""
n = int(input())
i = 1
count = 0
while i*i <= n:
    if n % i == 0:
        if i == n//i:
            count += 1
        else:
            count += 2
    i += 1
if count != 2:
    print('No')
else:
    print('Yes')

"""
Программа получает на вход натуральное число N. 
Нужно найти сумму его делителей. 
"""
n = int(input())
i = 1
a = []
while i * i <= n:
    if n % i == 0:
        a.append(i)
        if i != n//i:
            a.append(n//i)
    i += 1
a.sort()
print(sum(a))

"""
Гипотеза Коллатца
Сиракузская последовательность, или последовательность Коллатца, 
строится так: возьмём натуральное число n; если оно чётное, 
то заменим его числом n/2; если же оно нечётное, то заменим его числом 3n+1. 
Получившееся число — следующее в сиракузской последовательности после числа n. 
Затем заменяем получившееся число по тому же правилу, и так далее.
Определите, сколько шагов потребуется сиракузской последовательности, 
стартующей с заданного числа, чтобы прийти к 1.
Обычно, если проделать такую замену достаточно много раз, 
мы приходим к числу 1 (за которым следует снова 1). Например: 
8 → 4 → 2 → 1 или 10 → 5 → 16 → 8 → 4 → 2 → 1.
Определите, сколько шагов потребуется сиракузской последовательности, 
стартующей с заданного числа, чтобы прийти к 1.
Если вы обнаружите число, сиракузская последовательность от которого 
не приходит к 1, то... вы, скорее всего, ошиблись. 
Но если нет, то поздравляем: вы прославитесь, ведь вопрос о том, всегда ли 
сиракузская последовательность приходит к 1 (независимо от начального числа), 
давно будоражит умы математиков.
Формат ввода
Вводится одно натуральное число n.
Формат вывода
Выводится одно число — количество шагов, необходимое стартующей от n 
сиракузской последовательности, чтобы впервые дойти до 1.
"""
n = int(input())
count = 0
while n != 1:
    if n % 2 == 0:
        n = n / 2
        count +=1
    else:
        n = 3*n + 1
        count += 1
print(count)